#+TITLE: Gradle ClassWorlds Assembly Plugin

* Summary

The Gradle ClassWorlds Assembly Plugin is a simple [[http://www.gradle.org/][Gradle]] plugin that generates a simple runnable distribution of your project, using [[http://classworlds.codehaus.org/launchusage.html][Classworlds]] as application launcher.

Sometimes it is easier to ship your application as a simple *zip* archive instead of bothering with a sophisticated software installer.

Simplicity is exactly what this Gradle plugin provides:
 - You have an application that is launched via a main class.
 - Your application has a set of dependencies.
 - Launching the application is just a matter of having all the dependencies in the classpath and running the main method of your application entry point.
 - Zip it and ship it!

The generated zip assembly name follows the pattern =<project-name>-<project-version>.zip=.

Below is the standard folder structure of the zip assembly generated by the plugin.

: ApplicationFolder : (projectName-ProjectVersion)
: |
: --- boot: Contains the application launcher bootstrap jars
: |
: --- etc : Contains the launcher configuration
: |
: --- lib : Contains the application dependencies and build artifacts
: |
: --- bin : Contains the application launcher scripts (launcher.bat and launcher.sh)

* Installation and configuration

** Installation to your local Maven cache
*Note*: This plugin is not yet available on a hosted Maven repository.

Clone the project from GitHub and run =gradlew install=, to install the plugin into your local Maven cache.

** Integration setup

The first step consists into configuring the =buildscript= closure at the top of your Gradle build file. Then you can apply the =classworlds= plugin.

 : buildscript {
 :   repositories {
 :     mavenLocal()
 :     mavenCentral()
 :   }
 :
 :   dependencies {
 :     classpath 'com.rimerosolutions.gradle.plugins:gradle-classworlds-plugin:1.0'
 :   }
 : }
 : 
 : apply plugin: 'classworlds'

** Plugin configuration
The plugin expects two parameters (that are required):
 - =appMainClassName=: This is the full class name of the entry point of your application containing a =main= method.
 - =appLocationEnvVariableName=: This is the environment variable name used to locate your application installation, as well as for bootstrapping the launcher.

The configuration parameters can be specified inside a =classworlds= block in your Gradle build file.
 : classworlds {
 :   appMainClassName = "com.rimerosolutions.application.MainClass"
 :   appLocationEnvVariableName="YOUR_APPLICATION_ENVIRONMENT_VARIABLE"
 : }

* Tasks
The plugin provides only one task called =classworlds=.

The =classworlds= task generates a zip assembly of your project dependencies with UNIX and Windows application launchers.

Running the =classworlds= task will also trigger the =build= task to generate the project artifacts.
 : gradle classworlds

* Testing the generated runnable distribution
You must first set an environment variable matching the =appLocationEnvVariableName= parameter specified in your Gradle build file.

Unzip the generated zip assembly which is inside your build folder to the location of your choice.

For the instructions below, we'll suppose that =appLocationEnvVariableName= is set to =YOUR_APPLICATION_ENVIRONMENT_VARIABLE=.

** Unix/Linux (bash)
: export YOUR_APPLICATION_ENVIRONMENT_VARIABLE=SOME_FOLDER_LOCATION
: sh ${YOUR_APPLICATION_ENVIRONMENT_VARIABLE}/bin/launcher.sh

Use =setenv= instead of =export= if you're using =csh= or =tcsh= as UNIX/Linux shell.

** MS Windows
: set YOUR_APPLICATION_ENVIRONMENT_VARIABLE=SOME_FOLDER_LOCATION
: %YOUR_APPLICATION_ENVIRONMENT_VARIABLE%/bin/launcher.bat

* Possible enhancements
 - Configurable output folder for the generated assembly.
 - Auto-detection of the application installation folder from the launcher to avoid setting environment variables.
 - Publishing of the plugin to a free repository such as [[https://docs.sonatype.org/display/Repository/Sonatype+OSS+Maven+Repository+Usage+Guide][Sonatype]] for convenience.
 - Refactoring to make the code actually easily testable.
 - Using wildcards in the launcher configuration for jar file patterns.
