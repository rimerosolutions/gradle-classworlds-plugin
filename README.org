#+TITLE: Gradle ClassWorlds Assembly Plugin

* Summary

The Gradle ClassWorlds Assembly Plugin is a simple [[http://www.gradle.org/][Gradle]] plugin that generates a simple runnable distribution of your project, using [[http://classworlds.codehaus.org/launchusage.html][Classworlds]] as application launcher.

Sometimes it is easier to ship your application as a simple *zip* archive instead of bothering with a sophisticated software installer.

Simplicity is exactly what this Gradle plugin provides:
 - You have an application that is launched via a main class.
 - Your application has a set of dependencies.
 - Launching the application is just a matter of having all the dependencies in the classpath and running the main method of your application entry point.
 - Zip it and ship it!

The generated zip assembly name follows the pattern =<project-name>-<project-version>.zip=.

Below is the standard folder structure of the zip assembly generated by the plugin.

: ApplicationFolder : (projectName-ProjectVersion)
: |
: --- boot: Contains the application launcher bootstrap jars
: |
: --- etc : Contains the launcher configuration
: |
: --- lib : Contains the application dependencies and build artifacts
: |
: --- bin : Contains the application launcher scripts (launcher.bat and launcher.sh)

* Installation and configuration

** Installation to your local Maven cache
*Note*: This plugin is not yet available on a hosted Maven repository.

Clone the project from GitHub and run =gradlew install=, to install the plugin into your local Maven cache.

** Integration setup

The first step consists into configuring the =buildscript= closure at the top of your Gradle build file. Then you can apply the =classworlds= plugin.

 : buildscript {
 :   repositories {
 :     mavenLocal()
 :     mavenCentral()
 :   }
 :
 :   dependencies {
 :     classpath 'com.rimerosolutions.gradle.plugins:gradle-classworlds-plugin:1.0'
 :   }
 : }
 : 
 : apply plugin: 'classworlds'

** Plugin configuration
The plugin expects two parameters (that are required):
 - =appMainClassName=: This is the full class name of the entry point of your application containing a =main= method.
 - =appLocationEnvVariableName=: This is the environment variable name used to locate your application installation, as well as for bootstrapping the launcher.

The configuration parameters can be specified inside a =classworlds= block in your Gradle build file.
 : classworlds {
 :   appMainClassName = "com.rimerosolutions.application.MainClass"
 :   appLocationEnvVariableName="YOUR_APPLICATION_ENVIRONMENT_VARIABLE"
 : }

* Tasks
The plugin provides only one task called =classworlds=.

The =classworlds= task generates a zip assembly of your project dependencies with UNIX and Windows application launchers.

Running the =classworlds= task will also trigger the =build= task to generate the project artifacts.
 : gradle classworlds

* Testing the generated distribution
Unzip the generated zip assembly which is inside your build folder to the location of your choice.

You must first set an environment variable matching the =appLocationEnvVariableName= parameter specified in your Gradle build file.

For the instructions below, we'll suppose that =appLocationEnvVariableName= is set to =YOUR_APPLICATION_ENVIRONMENT_VARIABLE=.

** Unix/Linux (bash)
: export YOUR_APPLICATION_ENVIRONMENT_VARIABLE=SOME_FOLDER_LOCATION
: sh ${YOUR_APPLICATION_ENVIRONMENT_VARIABLE}/bin/launcher.sh

Use =setenv= instead of =export= if you're using =csh= or =tcsh= as UNIX/Linux shell.

** MS Windows
: set YOUR_APPLICATION_ENVIRONMENT_VARIABLE=SOME_FOLDER_LOCATION
: %YOUR_APPLICATION_ENVIRONMENT_VARIABLE%/bin/launcher.bat

* Possible enhancements
 - Configurable output folder for the generated assembly.
 - Auto-detection of the application installation folder from the launcher to avoid setting environment variables.
 - Publishing of the plugin to a free repository such as [[https://docs.sonatype.org/display/Repository/Sonatype+OSS+Maven+Repository+Usage+Guide][Sonatype]] for convenience.
 - Refactoring to make the code actually easily testable.
 - Using wildcards in the launcher configuration for jar file patterns.
