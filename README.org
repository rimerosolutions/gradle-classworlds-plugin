#+TITLE: Gradle ClassWorlds Assembly Plugin

* Summary

The Gradle ClassWorlds Assembly Plugin is a simple [[http://www.gradle.org/][Gradle]] plugin that generates a simple archived distribution of your project, using [[http://classworlds.codehaus.org/launchusage.html][Classworlds]] as application launcher.

Extract the archive(s) and it's ready to go! 

This plugin is an alternative to the [[http://www.gradle.org/docs/current/userguide/application_plugin.html][Gradle application plugin]]. 

In terms of transparency, launching and assembly capabilities, you can perform arbitrary actions with the staging directory via a configuration closure.

Sometimes it is easier to ship your application as a simple *zip* or *tar* archive instead of bothering with a sophisticated software installer.

The generated assembly name follows the pattern =<project-name>-<project-version>.<assemblyformat>=.

Below is the standard folder structure of assemblies generated by the plugin.

: ApplicationFolder : (projectName-ProjectVersion)
: |
: --- boot: Contains the application launcher bootstrap jars
: |
: --- etc : Contains the launcher configuration
: |
: --- lib : Contains the application dependencies and build artifacts
: |
: --- bin : Contains the application launcher scripts (run.bat and run.sh)

Simplicity is exactly what this Gradle plugin provides:
 - You have an application that is launched via a main class.
 - Your application has a set of dependencies.
 - Launching the application is just a matter of having all the dependencies in the classpath and running the main method of your application entry point.
 - Compress files into an archive and ship it!

* Installation and configuration

** Installation to your local Maven cache
*Note*: This plugin is not yet available on a hosted Maven repository.

Clone the project from GitHub and run =gradlew install=, to install the plugin into your local Maven cache.

** Integration setup

The first step consists into configuring the =buildscript= closure at the top of your Gradle build file. 

After that, you can apply the =classworlds= plugin.

 : buildscript {
 :   repositories {
 :     maven { url 'https://oss.sonatype.org/content/repositories/snapshots' }
 :   }
 :
 :   dependencies {
 :     classpath 'com.rimerosolutions.gradle.plugins:gradle-classworlds-plugin:0.0.1-SNAPSHOT'
 :   }
 : }
 : 
 : apply plugin: 'classworlds'

** Plugin configuration
The plugin has only one required input which is the main class name of your application.

The main class name configuration is provided via the =appMainClassName= variable in a configuration block.

Configuration parameters are to be specified inside a =classworlds= block in your Gradle build file.
: classworlds {
:   // mandatory inputs
:   appMainClassName = 'com.Main'
:
:   // optional inputs
:   appLocationEnvVariableName='APP_HOME_IF_YOU_NEED_IT'
:   assemblyFileName="application_default_is_project_name_and_version"
:   assemblyFormats = ['zip', 'tar'] // only zip by default
:   jvmOptions = '-Xms512m -Xmx1g' // default is -Xmx128m -Xmx512m
:
:   doWithStagingDir = { stagingFolder ->
:     println 'Customizations, other actions here if needed'
:   }
: }

* Tasks
The plugin provides only one task called =classworlds=.

The =classworlds= task generates a zip and/or tar assembly of your project with UNIX and Windows application launchers.

Running the =classworlds= task will also trigger the =build= task to generate the project artifacts.
 : gradle classworlds

* Testing the generated distribution
Unzip the generated zip assembly which is inside your build folder to the location of your choice.

** Unix/Linux (bash)
: APPLICATION_LOCATION/bin/run.sh

** MS Windows
: APPLICATION_LOCATION/bin/run.bat

* Future enhancements
 - Better use of Gradle inputs and outputs, still doing few manual values assignments.
 - Add classpath customizations to prepend folders/files to the classpath.
 - Avoid marking all files as executable when creating the archive(s).
 - Write more tests.
